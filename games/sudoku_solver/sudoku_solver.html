<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Sudoku Solver</title>
    <!-- sudoku solver/

    ‚îÇ‚îÄ‚îÄ index.html
    ‚îÇ‚îÄ‚îÄ style.css
    ‚îÇ‚îÄ‚îÄ script.js
    ‚îú‚îÄ‚îÄ js/
    |    ‚îÇ‚îÄ‚îÄ script.js
    ‚îú‚îÄ‚îÄ assets/
        ‚îÇ‚îÄ‚îÄ font/
        |    ‚îÇ‚îÄ‚îÄ Bangers-Regular.ttf
        |    ‚îÇ‚îÄ‚îÄ BowlbyOne-Regulat.ttf
        |    ‚îÇ‚îÄ‚îÄ Digital-italic.ttf
        ‚îÇ‚îÄ‚îÄ sounds/
        |    ‚îÇ‚îÄ‚îÄ bg-music.mp3
        |    ‚îÇ‚îÄ‚îÄ winner-trumpets.mp3
        |    ‚îÇ‚îÄ‚îÄ single-key-press.mp3
        ‚îÇ    ‚îî‚îÄ‚îÄ tap-sound.mp3
        ‚îÇ‚îÄ‚îÄ images/
        ‚îÇ   ‚îú‚îÄ‚îÄ fruits/
        ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ apple.png
        ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
        ‚îÇ   ‚îú‚îÄ‚îÄ animals/
        ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ lion.png
        ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
        ‚îÇ   ‚îî‚îÄ‚îÄ Shape/
        ‚îÇ       ‚îú‚îÄ‚îÄ shape3.png
        ‚îÇ       ‚îî‚îÄ‚îÄ ... -->

    <!-- Sudoku
        with seperate liberary files
        with responsive layout
        with 3 downloaded font
        with dark/light theme 
        with speak in english
        with timer display
        with popup window with conform buttons 
        with different sound 
        with different size of sudoku
            1 Board Size 25x25 [sub grid 5x5]
            2 Board Size 24x24 [sub grid 4x6]
            3 Board Size 22x22 [sub grid 11x2]
            4 Board Size 21x21 [sub grid 7x3]
            5 Board Size 20x20 [sub grid 5x4]
            6 Board Size 18x18 [sub grid 6x6]
            7 Board Size 16x16 [sub grid 4x4]
            8 Board Size 15x15 [sub grid 5x3]
            9 Board Size 14x14 [sub grid 7x2]
            10 Board Size 12x12 [sub grid 4x3]
            11 Board Size 10x10 [sub grid 5x2]
            12 Board Size 9x9 [sub grid 3x3]
            13 Board Size 8x8 [sub grid 4x2]
            14 Board Size 6x6 [sub grid 3x2]
            15 Board Size 4x4 [sub grid 2x2] -->
    <!-- <link rel="stylesheet" href="styles.css"> -->
    <style>
        :root {
            --bg: #f0f0f0;
            --text: #111;
            --border: #222325d4;
            --border-highlight: #eeff00;
            --accent: #22d3ee;
            --conflict: #ff0000;
            --note: #8a8f99;
            --solved: #135fc4;
            --numpad-bg: #fff;
            --box-shadow: rgba(0, 0, 0, 0.2);
            --cell-min: 25px;
            --cell-max: 96px;
            --cell-size: 20px;
            --cell-alt-bg: #cbcacad6;
        }

        body.dark {
            --bg: #121212;            
            --cell-min: 25px;
            --cell-max: 96px;
            --text: #e5e7eb;
            --border: #ffffffd9;
            --border-highlight: #fff700;
            --accent: #22d3ee;
            --conflict: #ff0000;
            --note: #7f8b9a;
            --solved: #82b1ff;
            --numpad-bg: #0b1530;
            --box-shadow: rgba(255, 255, 255, 0.5);
            --cell-alt-bg: #595959;
        }

        @font-face {
            font-family: 'HindiFontGajraj';
            src: url('assets/font/GajrajOne-Regular.ttf') format('truetype');
        }

        @font-face {
            font-family: 'EnglishFontBangers';
            src: url('assets/font/Bangers-Regular.ttf') format('truetype');
        }

        @font-face {
            font-family: 'Digital';
            src: url('assets/font/digital-italic.ttf') format('truetype');
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: Arial, Helvetica, sans-serif;
            font-size: 1.6vw;
        }

        html,
        body {
            height: 100%;
            margin: 0;
            background: var(--bg);
            color: var(--text);
            font-family: Inter, Segoe UI, Roboto, Arial;
            overflow: hidden
        }

        .app {
            height: 100vh;
            display: flex;
            flex-direction: column
        }

        .main {
            flex: 1;
            display: flex;
            gap: 1vw;
            padding: 0.8vw;
            align-items: stretch;
            overflow: hidden
        }

        /* controls */
        .controls {
            flex: 0 0 40%;
            background: var(--bg);
            padding: 0.2vw;
            border-radius: 1vw;
            overflow: auto;
        }

        h1 {
            text-align: center;
            font-size: 2vw;
            font-family: 'EnglishFontBangers', Arial, Helvetica, sans-serif;
            color: var(--fg);
            letter-spacing: .2vw;
            text-shadow: 0 1px 0 #030303,
                0 2px 0 #c9c9c9,
                0 3px 0 #bbb,
                0 4px 0 #b9b9b9,
                0 5px 0 #aaa,
                0 6px 1px var(--box-shadow),
                0 0 5px var(--box-shadow),
                0 1px 3px var(--box-shadow),
                0 3px 5px var(--box-shadow),
                0 5px 10px var(--box-shadow),
                0 10px 10px var(--box-shadow),
                0 20px 20px var(--box-shadow);
            margin-bottom: 0.3vw;
        }

        select,
        label {
            padding: 0.6vw 1vw;
            font-size: 1.6vw;
            margin: 0.2vw 0.2vw;
            /* margin-top: 0.1vh; */
            transition: background-color 0.3s, transform 0.2s;
            box-shadow: 0 0.5vw 2.5vw 0 var(--box-shadow);
            border-radius: 0.5vw;
            /* cursor: pointer; */
            background: var(--bg);
            color: var(--text);
            /* border: 0.2vw solid var(--border); */
            /* border: 0.2vw solid var(--cell-border); */
        }
        #lebelMaxSol {
            padding: 0.6vw 1vw;
        }

        @media (max-aspect-ratio:1/1), (max-width:768px),
        (max-height:720px) and (orientation:portrait) {
            .main {
                flex-direction: column
            }

            .controls {
                flex: 0 0 auto;
                background: var(--bg);
                padding: 0.2vw;
                border-radius: 1vw;
                overflow: auto;
            }

            .numpad {
                order: 10;
                display: flex;
                flex-direction: row;
                flex-wrap: wrap;
                align-content: center;
                justify-content: center;
                align-items: center;
                width: 100%;
                grid-template-columns: repeat(5, 1fr);
                gap: 0.2vw;
                padding: 0.2vw;
                background: var(--numpad-bg);
                border-radius: 1vw;
                box-shadow: 0 0.5vw 2.5vw 0 var(--box-shadow);
            }

            .nbtn {
                height: 6.4vw;
            }

            /* clamp cell size */
            /* :root {
                --cell-min: 1.2vw;
                --cell-max: 9vw;
            } */
        }

        /* .controls .row, */
        /* .controls, */
        .controls .btn  {
            gap: 0.8vw;
            align-items: center;
            flex-wrap: wrap;
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            padding: 0.4vw 0.4vw;
            margin: 0.6vw 0.6vw;
            font-size: 1.6vw;
            display: inline-block;
            transition: background-color 0.3s, transform 0.2s;
            box-shadow: 0 0.5vw 2.5vw 0 var(--box-shadow);
            border-radius: 0.5vw;
            background: var(--bg);
            color: var(--text);
            border: 0.2vw solid var(--border);
            cursor: pointer;
        }

        .controls .btn:hover  {
            opacity: 0.5;
        }

        button.primary {
            gap: 0.8vw;
            align-items: center;
            flex-wrap: wrap;
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            padding: 0.4vw 1vw;
            margin: 0.6vw 1vw;
            font-size: 1.6vw;
            display: inline-block;
            margin-top: 0.1vh;
            transition: background-color 0.3s, transform 0.2s;
            box-shadow: 0 0.5vw 2.5vw 0 var(--box-shadow);
            border-radius: 0.5vw;
            background: linear-gradient(90deg, var(--accent), #7c3aed);
            color: #fff;
            border-color: transparent;
            background: linear-gradient(180deg, #10b981, #059669);
            border: none;
            box-shadow: 0 1vw 4vw var(--box-shadow);
        }

        button.primary:hover {
            opacity: 0.6;
        } 

        .info {
            display: flex;
            flex-direction: row;
            justify-content: center;
            flex-wrap: wrap;
            border-radius: 0.8vw;
            gap: 0.2vw;
            color: var(--fg);
            box-shadow: 0 0.5vw 2.5vw 0 var(--box-shadow);
        }

        .info>div {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            align-content: center;
            justify-content: center;
            text-align: center;
            padding: 0.2vw;
            color: var(--fg);
            font-size: 1.2vw;
        }

        .status {
            margin-top: 0.5vw;
            padding: 0.5vw;
            border-radius: 0.8vw;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), transparent);
            min-height: 5vw;

            text-align: center;
            border: 0.2vw solid var(--border);
            background: var(--bg);
            color: var(--fg);
            font-size: 1.6vw;
            box-shadow: 0 0.5vw 2.5vw 0 var(--box-shadow);
        }

        .lebelMaxSolVal {
            width: 15%;
            padding-top: 0.4vh;
            padding-bottom: 0.3vh;
            padding-left: 0.8vw;
            padding-right: 0.8vw;
            font-size: 1.6vw;
            text-align: center;
            background: var(--bg);
            color: var(--fg);
            border: 0.2vw solid var(--border);
            border-radius: 0.8vw;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
            box-shadow: 0 2vw 2.5vw 0 rgba(0, 0, 0, 0.2);
        }

        .lebelMaxSolVal:hover {
            transform: scale(1.05);
        } 

        /* board area */
        .board-wrap {
            flex: 1;
            display: grid;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            padding: 0.6vw
        }

        .board {
            width: 100%;
            height: 100%;
            display: grid;
            gap: 0.1vw;
            border-radius: 0.8vw;
            padding: 0.6vw;
            background: transparent;
            box-shadow: 0 0.5vw 2.5vw 0 var(--box-shadow);
            overflow: hidden;
        }

        .cell {
            display: flex;            
            align-items: center;
            justify-content: center;
            position: relative;
            border-radius: 0.1vw;
            border: 0.1vw solid var(--border);
            font-size: calc(var(--cell-size) * 0.50);
            box-shadow: 0 0.5vw 2.5vw 0 var(--box-shadow);
            user-select: none
        }

        .cell:hover {
            opacity: 0.5;
        }

        .cell input {
            position: absolute;
            inset: 0;
            border: 0;
            background: transparent;
            text-align: center;
            font-weight: 700;
            pointer-events: none
        }

        .cell .notes {
            position: absolute;
            inset: 0.1vw;
            font-size: 0.5vw;
            display: grid;
            gap: 0.1vw;
            opacity: 0.95
        }

        .cell .notes span {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 4vw;
            color: var(--note);
            font-weight: 700
        }

        .cell.user input {
            color: var(--text);
            font-size: calc(var(--cell-size) * 0.50);
        }

        .cell.solved input {
            color: var(--solved);
            font-size: calc(var(--cell-size) * 0.50);
        }

        .cell.conflict {
            border: 0.2vw solid var(--conflict);

        }

        .cell.selected {
            font-size: calc(var(--cell-size) * 0.750);
            outline: 0.3vw solid rgba(11, 116, 222, 0.14);
            z-index: 2
        }

        .row-highlight {
            border: 0.2vw solid var(--border-highlight);
        }

        .col-highlight {
            border: 0.2vw solid var(--border-highlight);
        }

        .cell.alt-bg {
            background: var(--cell-alt-bg);
        }

        .numpad {
            margin-top: 0.5vw;
            margin-bottom: 0.5vw;
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            align-content: center;
            justify-content: center;
            align-items: center;
            width: 100%;
            grid-template-columns: repeat(5, 1fr);
            gap: 0.2vw;
            padding: 0.2vw;
            background: var(--numpad-bg);
            border-radius: 1vw;
            box-shadow: 0 0.5vw 2.5vw 0 var(--box-shadow);
        }

        .nbtn {
            border-radius: 0.8vw;
            border: 0.2vw solid var(--border);
            background: var(--bg);
            width: 3vw;
            height: 3vw;
            color: var(--fg);
            font-size: 1vw;
            font-weight: 800;
            position: relative;
            cursor: pointer;
            box-shadow: 0 0.5vw 2.5vw 0 var(--box-shadow);
        }

        .nbtn:hover {
            opacity: 0.5;
        }

        .nbtn.selected {
            background: var(--accent);
            color: white
        }

        .nbtn .counter {
            position: absolute;
            right: 0.2vw;
            top: 1.8vw;
            font-size: 0.6vw;
            color: var(--note);
        }

        /* avoid scrollbars on controls but allow internal scroll if narrow*/
        .controls::-webkit-scrollbar {
            width: 0.8vw;
            height: 0.8vw
        }

        .controls::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.06);
            border-radius: 0.6vw
        }

        /* Warn window */
        .warnbar {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background: var(--bg);
            color: var(--fg);
            border: 0.1vw solid var(--cell-border);
            border-radius: 1.4vw;
            padding: 1vw;
            z-index: 10001;
            display: none;
            gap: 1vw;
            align-items: center;
            flex-wrap: wrap;
            box-shadow: 0 1vw 4vw rgba(0, 0, 0, .45);
        }

        .warnbar.show {
            display: flex;
        }

        .warnbar .row {
            display: flex;
            align-items: center;
            gap: 0.8vw;
            background: var(--bg);
            padding: 0.6vh 0.8vw;
            border-radius: 1vw;
        }

        .warnbar label {
            color: var(--fg);
            font-size: 1.2vw;
        }
    </style>
</head>

<body data-theme="light">
    <div class="app">
        <div class="main">
            <aside class="controls">
                <h1>Sudoku Solver</h1>
                    <label>Size</label>
                    <select id="sizeSelect"></select>
                    <!-- <button class="btn" id="newBtn">New Game</button> -->
                    <!-- <button class="btn" id="startBtn">Start / Fill</button> -->
                    <label id="lebelMaxSol" for="maxSolutions">Max Solutions <input id="maxSolutions" class="lebelMaxSolVal" type="number" value="1" min="1" max="100"/></label>
                    
                    <button class="primary" id="solveBtn">üîì Solve</button>
                    <button class="btn" id="unsolveBtn">üîíUnsolve</button>
                    <button class="btn" id="resetBtn">üîÑ Reset</button>
                    <button class="btn" id="undoBtn">‚Ü∂ Undo</button>
                    <button class="btn" id="themeToggle">üåô Dark</button>
                    <button class="btn" id="toggle-sound">üîá Music:Off"</button>
                <!-- <div id="info"> -->
                    <!-- <label><input type="checkbox" id="altBgToggle"> Alternate subgrid bg</label> -->
                    <!-- <label><input type="checkbox" id="notesToggle" checked> Notes</label> -->

                <div class="info">
                        <!-- <div>Timer</div> -->
                        <div id="timer">‚è± 00:00:00</div>
                        <button class="btn" id="pauseBtn">‚è∏Pause</button>
                        <div id="filledInfo">Filled: 0</div>
                        <div id="remainInfo">Empty: 0</div>
                        <div id="totalInfo">Total: 0</div>
                </div>

                <div id="numpad" class="numpad"></div>
                
                <div class="info">
                        <div class="small">Solutions</div>
                        <button class="btn" id="prevSol">Prev</button>
                        <div id="solIndex">0 / 0</div>
                        <button class="btn" id="nextSol">Next</button>
                </div>
                <div class="status" id="status">Ready ‚Äî select size and click Start</div>
            </aside>

            <section class="board-wrap">
                <div id="boardContainer" class="board" aria-label="Sudoku board"></div>
            </section>
        </div>
    </div>
    <!-- Warning popup window -->
    <div class="warnbar" id="warnbar" aria-live="polite">
        <div class="row">
            <label id="warntext">Bigger the grid size and higher the no of solution may slow the solving process
            </label>
            <button id="warn" class="primary">Ok</button>
        </div>
    </div>
    <!-- Conformation popup window -->
    <div class="warnbar" id="conformbar">
        <div class="row">
            <p>Your filled data will be lost, are you sure?</p>
            <button id="confirmYes" class="primary">Yes</button>
            <button id="confirmNo" class="primary">No</button>
        </div>
    </div>
    <script>
        // sizes with box rows/cols 
        const sizes = [
            { n: 25, box: [5, 5] }, { n: 24, box: [3, 4] }, { n: 22, box: [2, 11] }, { n: 21, box: [3, 7] }, { n: 20, box: [4, 5] },
            { n: 18, box: [3, 6] }, { n: 16, box: [4, 4] }, { n: 15, box: [3, 5] }, { n: 14, box: [2, 7] }, { n: 12, box: [3, 4] },
            { n: 10, box: [2, 5] }, { n: 9, box: [3, 3] }, { n: 8, box: [2, 4] }, { n: 6, box: [2, 3] }, { n: 4, box: [2, 2] }
        ];

        /* Elements */
        const el = {
            maxSols: document.getElementById('maxSolutions'),
            sizeSelect: document.getElementById('sizeSelect'),
            warnText: document.getElementById('warntext'),
            // startBtn: document.getElementById('startBtn'),
            // newBtn: document.getElementById('newBtn'),
            solveBtn: document.getElementById('solveBtn'),
            unsolveBtn: document.getElementById('unsolveBtn'),
            resetBtn: document.getElementById('resetBtn'),
            undoBtn: document.getElementById('undoBtn'),
            pauseBtn: document.getElementById('pauseBtn'),
            status: document.getElementById('status'),
            numpad: document.getElementById('numpad'),
            boardContainer: document.getElementById('boardContainer'),
            themeToggle: document.getElementById('themeToggle'),
            // notesToggle: document.getElementById('notesToggle'),
            timerEl: document.getElementById('timer'),
            prevSol: document.getElementById('prevSol'),
            nextSol: document.getElementById('nextSol'),
            solIndexEl: document.getElementById('solIndex'),
            filledInfo: document.getElementById('filledInfo'),
            remainInfo: document.getElementById('remainInfo'),
            totalInfo: document.getElementById('totalInfo'),

            yesBtn: document.getElementById('confirmYes'),
            noBtn: document.getElementById('confirmNo'),
            conformbar: document.getElementById('conformbar'),

        };

        sizes.sort((a, b) => a.n - b.n);
        sizes.forEach(s => {
            const o = document.createElement('option'); o.value = s.n; o.textContent = `${s.n} (${s.box[0]}x${s.box[1]})`;
            el.sizeSelect.appendChild(o);
        });
        el.sizeSelect.value = 9;

        // state ---------- */
        let N = 9, boxR = 3, boxC = 3;            // current size & box dimensions
        let grid = [], userGrid = [], notesGrid = []; // grid values and which are user-filled
        let selectedDigit = null, selectedCell = null;
        let undoStack = [];
        let solutions = [], solIndex = 0, solvedMode = false;
        let timer = 0, timerInterval = null, paused = false;
        let solverAbort = false, solvingInBackground = false;
        let filledcell = 0;
        let conform = false;
        el.filledInfo.textContent = `Filled: ${filledcell}`;
        el.remainInfo.textContent = `Empty: ${N * N - filledcell}`;
        el.totalInfo.textContent = `Total: ${N * N}`;

        // build board DOM (as per size)
        function buildBoard(n, box) {
            N = n; 
            boxR = box[0]; 
            boxC = box[1];
            grid = []; 
            userGrid = []; 
            notesGrid = []; 
            undoStack = []; 
            solutions = []; 
            solIndex = 0; 
            solvedMode = false; 
            solverAbort = false; 
            solvingInBackground = false;
            el.solIndexEl.textContent = '0 / 0';
            adjustSizes();
            el.boardContainer.style.gridTemplateColumns = `repeat(${N}, var(--cell-size))`;
            el.boardContainer.innerHTML = '';
            // el.boardContainer.style.gridTemplateColumns = `repeat(${N}, 1fr)`;
            // el.boardContainer.style.gridTemplateRows = `repeat(${N}, 1fr)`;
            for (let r = 0; r < N; r++) { 
                grid[r] = Array(N).fill(0); 
                userGrid[r] = Array(N).fill(0); 
                notesGrid[r] = Array(N).fill([]); 
            }
            for (let r = 0; r < N; r++) {
                for (let c = 0; c < N; c++) {
                    const cell = document.createElement('div'); 
                    cell.className = 'cell';
                    cell.tabIndex = 0;
                    cell.dataset.r = r; 
                    cell.dataset.c = c;
                    cell.dataset.val = '';
                    // subgrid alternate bg
                    const br = Math.floor(r / boxR), bc = Math.floor(c / boxC);
                    // console.log(el.altBgToggle.checked, br, bc, (br + bc) % 2)
                    if ((br + bc) % 2 === 1) cell.classList.add('alt-bg');
                    const input = document.createElement('input'); 
                    input.readOnly = true; 
                    input.dataset.r = r; 
                    input.dataset.c = c;
                    cell.appendChild(input);
                    const noteWrap = document.createElement('div'); 
                    noteWrap.className = 'notes';
                    cell.appendChild(noteWrap);
                    // thicker lines
                    if (c % boxC === boxC - 1) cell.style.borderRightWidth = '0.3vw';
                    if (r % boxR === boxR - 1) cell.style.borderBottomWidth = '0.3vw';
                    if (c % boxC === 0) cell.style.borderLeftWidth = '0.3vw';
                    if (r % boxR === 0) cell.style.borderTopWidth = '0.3vw';
                    cell.addEventListener('click', () => onCellClick(r, c));
                    cell.addEventListener('keydown', (e) => onCellKeydown(e, r, c));
                    el.boardContainer.appendChild(cell);
                }
            }
            buildNumpad();
            updateCounters();
            setStatus('click numpad number first then a cell');
            setTimeout(adjustSizes, 50);
        }

        // grid sizing (auto-scale with game size)
        function adjustSizes() {
            const wrap = document.querySelector('.board-wrap');
            const rect = wrap.getBoundingClientRect();
            const pad = 12;
            const availW = Math.max(40, rect.width - pad); 
            const availH = Math.max(40, rect.height - pad);
            const gap = 3;
            const sizeW = Math.floor((availW - gap * N) / N);
            const sizeH = Math.floor((availH - gap * N) / N);
            let cellSize = Math.max(16, Math.floor(Math.min(sizeW, sizeH)));
            cellSize = Math.max(16, Math.min(cellSize, 96));
            const sizePx = cellSize;
            document.documentElement.style.setProperty('--cell-size', sizePx + 'px');
        }

        // numpad 
        function buildNumpad() {
            el.numpad.innerHTML = '';
            for (let d = 1; d <= N; d++) {
                const btn = document.createElement('button'); 
                btn.className = 'nbtn'; 
                btn.dataset.d = d; 
                btn.textContent = d;
                const cspan = document.createElement('span'); 
                cspan.className = 'counter'; 
                btn.appendChild(cspan);
                btn.addEventListener('click', () => { 
                    if(solvedMode) return;
                    playSound('tap');
                    selectedDigit = d; 
                    updateNumpadSelection(); 
                    setStatus(`Numpad ${d} Selected, Click cell to mark ${d}, after fill click Solve`); 
                    highlightDigit(d); 
                });
                el.numpad.appendChild(btn);
            }
            const back = document.createElement('button'); 
            back.className = 'nbtn'; 
            back.textContent = '‚å´'; 
            back.title = 'Remove selected cell';
            back.addEventListener('click', () => { 
                selectedDigit = 'back'; 
                updateNumpadSelection(); 
                textToSpeechEng('back selected');
                setStatus('back selected, click cell to remove number');
            });
            el.numpad.appendChild(back);
            updateNumpadSelection(); 
            updateCounters();
        }

        function updateNumpadSelection() {
            [...el.numpad.children].forEach(b => {
                const d = b.dataset.d;
                if ((selectedDigit === 'back' && b.textContent === '‚å´') || (d && Number(d) === selectedDigit)) b.classList.add('selected'); else b.classList.remove('selected');
            });
        }
        function updateCounters() {
            const counts = Array(N + 1).fill(0);
            for (let r = 0; r < N; r++) for (let c = 0; c < N; c++) { const v = userGrid[r][c]; if (v) counts[v]++; }
            for (let d = 1; d <= N; d++) { const btn = el.numpad.children[d - 1]; if (!btn) continue; const remain = (N - counts[d]); btn.querySelector('.counter').textContent = remain > 0 ? remain : ''; }
        }

        // cell interactions with mouse
        function onCellClick(r, c) {
            if(solvedMode) return;
            playSound('tap');
            selectedCell = [r, c]; 
            refreshSelection();
            if (selectedDigit === 'back') { // clear
                if (userGrid[r][c]) { 
                    textToSpeechEng('number removed');
                    pushUndo({ r, c, prev: userGrid[r][c] }); 
                    userGrid[r][c] = 0; 
                    grid[r][c] = 0; 
                    filledcell--;
                    el.filledInfo.textContent = `Filled: ${filledcell}`;
                    el.remainInfo.textContent = `Empty: ${N * N - filledcell}`;
                    el.totalInfo.textContent = `Total: ${N * N}`;
                    refreshCell(r, c); 
                    updateCounters(); 
                    checkConflicts(); 
                }
                return;
            }
            if (!selectedDigit) { setStatus('Select numpad number first to fill board'); return; }
            if(selectedDigit > 0 && userGrid[r][c] == 0){
                pushUndo({ r, c, prev: userGrid[r][c] });
                userGrid[r][c] = selectedDigit; 
                grid[r][c] = selectedDigit;
                filledcell++;
                refreshCell(r, c); 
                updateCounters(); 
                checkConflicts();
                el.filledInfo.textContent = `Filled: ${filledcell}`;
                el.remainInfo.textContent = `Empty: ${N * N - filledcell}`;
                el.totalInfo.textContent = `Total: ${N * N}`;
            }
        }

        // cell interactions with keyboard
        function onCellKeydown(e, r, c) {
            if(solvedMode) return;
            if (e.key >= '1' && e.key <= String(N)) {
                playSound('key');
                selectedDigit = parseInt(e.key); updateNumpadSelection(); onCellClick(r, c);
            } else if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                playSound('key');
                e.preventDefault(); navigateArrow(r, c, e.key);
            } else if (e.key === 'Backspace' || e.key === 'Delete') {
                if (e.key === 'Backspace') textToSpeechEng('Backspace');
                if (e.key === 'Delete') textToSpeechEng('Delete');
                pushUndo({ r, c, prev: userGrid[r][c] }); userGrid[r][c] = 0; grid[r][c] = 0; refreshCell(r, c); updateCounters(); checkConflicts();
                filledcell--;
                el.filledInfo.textContent = `Filled: ${filledcell}`;
                el.remainInfo.textContent = `Empty: ${N * N - filledcell}`;
                el.totalInfo.textContent = `Total: ${N * N}`;
            }
        }

        //arrow keys
        function navigateArrow(r, c, key) {
            let nr = r, nc = c;
            if (key === 'ArrowUp') nr = (r - 1 + N) % N;
            if (key === 'ArrowDown') nr = (r + 1) % N;
            if (key === 'ArrowLeft') nc = (c - 1 + N) % N;
            if (key === 'ArrowRight') nc = (c + 1) % N;
            const idx = nr * N + nc; const cell = el.boardContainer.children[idx];
            if (cell) { cell.focus(); selectedCell = [nr, nc]; refreshSelection(); }
        }

        function refreshCell(r, c) {
            const idx = r * N + c; 
            const elCell = el.boardContainer.children[idx]; 
            const val = grid[r][c]; 
            const input = elCell.querySelector('input');
            input.value = val ? val : '';
            elCell.dataset.val = val || '';
            elCell.classList.toggle('user', !!userGrid[r][c]);
            elCell.classList.toggle('solved', solvedMode && !userGrid[r][c] && val);

            //for notes
            // const noteWrap = elCell.querySelector('.notes'); 
            // noteWrap.innerHTML = '';
            // if (el.notesToggle.checked && !val) {
                // const maxCols = Math.ceil(Math.sqrt(N)); 
                // noteWrap.style.gridTemplateColumns = `repeat(${maxCols},1fr)`;
                // const cand = getCandidates(r, c);
                // for (let i = 1; i <= N; i++) { 
                //     const sp = document.createElement('span'); 
                //     sp.textContent = cand.includes(i) ? i : ''; 
                //     noteWrap.appendChild(sp); 
                // }
            // }
        }

        function refreshAll() {
            console.log(userGrid, grid);
            filledcell = 0;
            for (let r = 0; r < N; r++) for (let c = 0; c < N; c++) {
                refreshCell(r, c);
                if (grid[r][c] > 0) filledcell++;
            } 
            console.log(filledcell, N * N - filledcell);
            el.filledInfo.textContent = `Filled: ${filledcell}`;
            el.remainInfo.textContent = `Empty: ${N * N - filledcell}`;
            el.totalInfo.textContent = `Total: ${N * N}`;
            refreshSelection(); updateCounters(); checkConflicts();
        }

        function refreshSelection() {
            document.querySelectorAll('.cell').forEach(elc => elc.classList.remove('selected', 'row-highlight', 'col-highlight'));
            if (!selectedCell) return;
            const [r, c] = selectedCell; 
            const idx = r * N + c; 
            const elc = el.boardContainer.children[idx];
            if (elc) elc.classList.add('selected');
            for (let i = 0; i < N; i++) { 
                el.boardContainer.children[r * N + i].classList.add('row-highlight'); 
                el.boardContainer.children[i * N + c].classList.add('col-highlight'); 
            }
        }

        // undo / status
        function pushUndo(e) { 
            undoStack.push(e); 
            if (undoStack.length > 1000) undoStack.shift(); 
        }

        function doUndo() { 
            if(solvedMode) return;
            const last = undoStack.pop(); if (!last) return; textToSpeechEng('Undo'); grid[last.r][last.c] = last.prev || 0; userGrid[last.r][last.c] = last.prev || 0; refreshCell(last.r, last.c); updateCounters(); checkConflicts(); 
        }

        function setStatus(t) { 
            el.status.textContent = t; 
        }

        // conflicts & candidates
        function checkConflicts() {
            document.querySelectorAll('.cell').forEach(c => c.classList.remove('conflict'));
            // rows
            for (let r = 0; r < N; r++) {
                const seen = {};
                for (let c = 0; c < N; c++) { const v = userGrid[r][c]; if (!v) continue; if (seen[v]) { el.boardContainer.children[r * N + c].classList.add('conflict'); el.boardContainer.children[r * N + (seen[v] - 1)].classList.add('conflict'); } else seen[v] = c + 1; }
            }
            // cols
            for (let c = 0; c < N; c++) {
                const seen = {};
                for (let r = 0; r < N; r++) { const v = userGrid[r][c]; if (!v) continue; if (seen[v]) { el.boardContainer.children[r * N + c].classList.add('conflict'); el.boardContainer.children[(seen[v] - 1) * N + c].classList.add('conflict'); } else seen[v] = r + 1; }
            }
            // boxes
            for (let br = 0; br < boxR; br++) for (let bc = 0; bc < boxC; bc++) {
                const seen = {};
                for (let r = br * boxR; r < br * boxR + boxR; r++) for (let c = bc * boxC; c < bc * boxC + boxC; c++) {
                    const v = userGrid[r][c]; if (!v) continue;
                    const key = v;
                    if (seen[key]) { el.boardContainer.children[r * N + c].classList.add('conflict'); const [pr, pc] = seen[key]; el.boardContainer.children[pr * N + pc].classList.add('conflict'); }
                    else seen[key] = [r, c];
                }
            }
        }

        function getCandidates(r, c) {
            if (grid[r][c]) return [];
            const used = new Set();
            for (let i = 0; i < N; i++) { if (userGrid[r][i]) used.add(userGrid[r][i]); if (userGrid[i][c]) used.add(userGrid[i][c]); }
            const br = Math.floor(r / boxR) * boxR, bc = Math.floor(c / boxC) * boxC;
            for (let rr = br; rr < br + boxR; rr++) for (let cc = bc; cc < bc + boxC; cc++) if (userGrid[rr][cc]) used.add(userGrid[rr][cc]);
            const arr = []; for (let d = 1; d <= N; d++) if (!used.has(d)) arr.push(d); return arr;
        }

        function highlightDigit(d) {
            document.querySelectorAll('.cell').forEach(c => c.classList.remove('digit-highlight'));
            if (!d || d === 'back') return;
            document.querySelectorAll(`.cell[data-val="${d}"]`).forEach(c => c.classList.add('digit-highlight'));
        }

        // Solver (async, optimized)
        function selectNextCellOptimized(g) {
            // choose empty cell with fewest candidates (MRV), tie-breaker: row+col+box fill count (higher better)
            let best = null; let bestCandCount = Infinity; let bestScore = -1;
            for (let r = 0; r < N; r++) for (let c = 0; c < N; c++) {
                if (g[r][c]) continue;
                // candidates
                const cand = [];
                for (let d = 1; d <= N; d++) { if (validFor(g, r, c, d)) cand.push(d); }
                const candCount = cand.length;
                if (candCount === 0) return { r, c, cand: [] }; // dead end
                // score = how filled the row/col/box already are
                let rowFill = 0, colFill = 0, boxFill = 0;
                for (let k = 0; k < N; k++) { if (g[r][k]) rowFill++; if (g[k][c]) colFill++; }
                const br0 = Math.floor(r / boxR), bc0 = Math.floor(c / boxC);
                for (let rr = br0 * boxR; rr < br0 * boxR + boxR; rr++) for (let cc = bc0 * boxC; cc < bc0 * boxC + boxC; cc++) if (g[rr][cc]) boxFill++;
                const score = rowFill + colFill + boxFill;
                if (candCount < bestCandCount || (candCount === bestCandCount && score > bestScore)) {
                    best = { r, c, cand }; bestCandCount = candCount; bestScore = score;
                }
            }
            return best; // {r,c,cand}
        }

        function validFor(g, r, c, v) {
            for (let i = 0; i < N; i++) { if (g[r][i] === v) return false; if (g[i][c] === v) return false; }
            const br0 = Math.floor(r / boxR) * boxR, bc0 = Math.floor(c / boxC) * boxC;
            for (let rr = br0; rr < br0 + boxR; rr++) for (let cc = bc0; cc < bc0 + boxC; cc++) if (g[rr][cc] === v) return false;
            return true;
        }

        async function solveAllAsync(maxSolutions, onProgress, onFirst) {
            solverAbort = false; solvingInBackground = true;
            const g = userGrid.map(r => r.slice());
            const solutionsLocal = [];
            let nodes = 0, lastYield = performance.now();

            // backtracking
            async function bt() {
                if (solverAbort) return;
                const pick = selectNextCellOptimized(g);
                if (!pick) { // solved
                    solutionsLocal.push(g.map(row => row.slice()));
                    if (onProgress) onProgress(solutionsLocal.length);
                    if (solutionsLocal.length === 1 && onFirst) onFirst(solutionsLocal[0]);
                    return;
                }
                // dead end check
                if (pick.cand.length === 0) return;
                // order candidates by frequency (most frequent first)
                const freq = Array(N + 1).fill(0);
                for (let rr = 0; rr < N; rr++) for (let cc = 0; cc < N; cc++) { const v = g[rr][cc]; if (v) freq[v]++; }
                pick.cand.sort((a, b) => freq[b] - freq[a]);

                const { r, c } = pick;
                for (const v of pick.cand) {
                    if (solverAbort) return;
                    g[r][c] = v; nodes++;
                    // yield occasionally to keep UI responsive
                    if (nodes % 3000 === 0 || (performance.now() - lastYield) > 120) {
                        lastYield = performance.now();
                        await new Promise(res => setTimeout(res, 0));
                    }
                    await bt();
                    g[r][c] = 0;
                    if (solverAbort) return;
                    if (solutionsLocal.length >= maxSolutions) return;
                }
            }

            await bt();
            solvingInBackground = false;
            return solutionsLocal;
        }

        // Apply/clear solutions
        function applySolution(sol) {
            for (let r = 0; r < N; r++) for (let c = 0; c < N; c++) if (!userGrid[r][c]) grid[r][c] = sol[r][c];
            solvedMode = true; refreshAll();
        }

        function clearSolution() {
            solvedMode = false;
            for (let r = 0; r < N; r++) for (let c = 0; c < N; c++) if (!userGrid[r][c]) grid[r][c] = 0;
            refreshAll();
        }

        // base solution for empty board
        function generateBaseSolution(n, r, c) {
            const sol = Array.from({ length: n }, () => Array(n).fill(0));
            for (let row = 0; row < n; row++) {
                for (let col = 0; col < n; col++) {
                    const num = ((row * c + Math.floor(row / r) + col) % n) + 1;
                    sol[row][col] = num;
                }
            }
            return sol;
        }

        // Solve flow (first solution immediate + background)
        async function startSolveFlow() {
            warnbar.classList.remove('show');
            const maxSol = Math.max(1, Math.min(1000, parseInt(el.maxSols.value) || 2));
            // check for 25% filled or not
            // if(N >= 12 && filled < Math.ceil(total * 0.25)){
            //     // el.warnText.textContent = "Bigger no of solution may and bigger the size may slow the solving process";
            //     // warnbar.classList.add('show');
            //     setStatus(`Too few clues for ${N}√ó${N}. Need at least ${Math.ceil(total*0.25)} clues (25%).`);
            //     textToSpeechEng(`Fill more ${Math.ceil(total*0.25) - filled} numbers`);
            //     return;
            // }
            const filled = userGrid.flat().filter(v => v).length;
            const total = N * N;
            if (filled === 0) {
                const base = generateBaseSolution(N, boxR, boxC);
                applySolution(base);
                setStatus('Empty Board - Only Base solution shown.');
                textToSpeechEng('Base Solition');
                return;
            }

            setStatus('Solving: searching (first solution will appear as soon as found)...');
            solutions = []; 
            solIndex = 0; 
            updateSolNav(); 
            solverAbort = false; 
            solvingInBackground = true;

            // progress callback: update status live
            const onProgress = (count) => {
                setStatus(`Computer working ‚Äî solutions found: ${count}`);
                el.solIndexEl.textContent = `${solIndex + 1} / ${Math.max(1, count)}`;
            };

            // first-solution callback: apply immediately
            const onFirst = (sol) => {
                applySolution(sol);
                stopTimer();
                setStatus('First solution shown. Continuing search in background...');
                textToSpeechEng('First Solition');
                el.filledInfo.textContent = `Filled: ${filledcell}`;
                el.remainInfo.textContent = `Empty: ${N * N - filledcell}`;
                el.totalInfo.textContent = `Total: ${N * N}`;
            };
            // run solver (async)
            const sols = await solveAllAsync(maxSol, onProgress, onFirst);

            solutions = sols;
            if (solutions.length === 0) {
                setStatus('No solution found.');
                textToSpeechEng('No solution found');
                solvingInBackground = false;
                return;
            }

            // ensure first solution is applied
            if (!solvedMode && solutions.length > 0) {
                applySolution(solutions[0]);
            }
            setStatus(`Search complete (found ${solutions.length} solution(s)`);
            solIndex = 0; updateSolNav();
            selectedCell = null;
            selectedDigit = null;
            document.querySelectorAll('.cell').forEach(c => c.classList.remove('selected', 'row-highlight', 'col-highlight'));
            document.querySelectorAll('.nbtn').forEach(elc => elc.classList.remove('selected'));
            stopTimer();
        }

        // update solution navigation
        function updateSolNav() { 
            el.solIndexEl.textContent = (solutions.length ? `${solIndex + 1} / ${solutions.length}` : '0 / 0'); 
        }

        //max solution change
        el.maxSols.addEventListener('input', function () {
            let inputval = this.value;
            console.log(inputval);
            const maxSol = Math.max(1, Math.min(1000, parseInt(inputval) || 2));
            if (maxSol>10) {
                el.warnText.textContent = "Higher the no of solution and Bigger the grid size may slow the solving process";
                warnbar.classList.add('show');
            } else {
                warnbar.classList.remove('show');
            }
        });

        //size change
        el.sizeSelect.addEventListener('click', () => {
            const n = parseInt(el.sizeSelect.value); 
            if (n>12) {
                el.warnText.textContent = "Bigger the grid size and higher the no of solution may slow the solving process";
                warnbar.classList.add('show');
            } else {
                warnbar.classList.remove('show');
            }
            const opt = sizes.find(s => s.n === n);
            buildBoard(n, opt.box); 
            setStatus('New board Ready ‚Äî Click number to start fill board');
            refreshAll();
            startTimer();
        });

        //show warning popup
        document.getElementById('warn').addEventListener('click', () => {
            warnbar.classList.remove('show');
        });

        // action to check after 25% number filledd or not
        // click warning window ok button
        // el.sizeSelect.addEventListener('click', () => {
        //     const n = parseInt(el.sizeSelect.value); 
        //     if (n>12) {
        //         warnbar.classList.add('show');
        //     }
        //     const opt = sizes.find(s => s.n === n);
        //     buildBoard(n, opt.box); 
        //     startTimer();
        // });

        //new button
        // el.newBtn.addEventListener('click', () => {
        //     const n = parseInt(el.sizeSelect.value); 
        //     const opt = sizes.find(s => s.n === n);
        //     buildBoard(n, opt.box); 
        //     setStatus('New board ready');
        // });

        // solve
        el.solveBtn.addEventListener('click', () => startSolveFlow());

        // unsolve
        el.unsolveBtn.addEventListener('click', () => { 
            if(!solvedMode) return;
            solverAbort = true; 
            clearSolution(); 
            solutions = []; 
            solIndex = 0; 
            updateSolNav(); 
            textToSpeechEng('unsolve');
            setStatus('Unsolved / aborted, you can fill/reomve number from board'); 
        });

        //reset
        el.resetBtn.addEventListener('click', () => { 
            textToSpeechEng('reset');
            conformbar.style.display = 'block';
        });
        
        //undo
        el.undoBtn.addEventListener('click', () => doUndo());

        // prev or next solution
        el.prevSol.addEventListener('click', () => { textToSpeechEng('Previous'); if (solutions.length === 0) return; solIndex = (solIndex - 1 + solutions.length) % solutions.length; applySolution(solutions[solIndex]); updateSolNav(); });
        el.nextSol.addEventListener('click', () => { textToSpeechEng('Next'); if (solutions.length === 0) return; solIndex = (solIndex + 1) % solutions.length; applySolution(solutions[solIndex]); updateSolNav(); });

        //theme change
        el.themeToggle.addEventListener('click', () => {
            document.body.classList.toggle("dark");
            if (document.body.classList.contains("dark")) {
                el.themeToggle.innerText = "‚òÄÔ∏è Light";
                textToSpeechEng('Theme Light');
            } else {
                el.themeToggle.innerText = "üåô Dark";
                textToSpeechEng('Theme Dark');
            }
        });
        
        //reset yes button
        el.yesBtn.addEventListener('click', () => {
            conformbar.style.display = 'none';
            for (let r = 0; r < N; r++) for (let c = 0; c < N; c++) { userGrid[r][c] = 0; grid[r][c] = 0; } 
            refreshAll(); 
            undoStack = []; 
            setStatus('Board reset, Select numpad number first to fill'); 
            return;
        });

        //reset no button
        el.noBtn.onclick = function () {
            conformbar.style.display = 'none';
            return;
        }

        // key's action
        window.addEventListener('keydown', (e) => {
            if(solvedMode) return;
            if (!selectedCell) return;
            const [r, c] = selectedCell;
            if (e.key >= '0' && e.key <= String(Math.max(9, N))) { // numeric
                const val = Number(e.key);
                pushUndo({ r, c, prev: userGrid[r][c] });
                userGrid[r][c] = val || 0; grid[r][c] = val || 0; refreshCell(r, c); updateCounters(); checkConflicts();
                e.preventDefault();
            } else if (e.key === 'Backspace' || e.key === 'Delete') {
                pushUndo({ r, c, prev: userGrid[r][c] }); userGrid[r][c] = 0; grid[r][c] = 0; refreshCell(r, c); updateCounters(); checkConflicts(); e.preventDefault();
            } else if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                navigateArrow(r, c, e.key);
            }
        });

        /* timer */
        function startTimer() { 
            stopTimer(); 
            let timess = 0;
            let timemm = 0;
            let timehh = 0;
            el.timerEl.textContent = '‚è±Ô∏è 00:00:00'; 
            timer = Date.now();
            timerInterval = setInterval(() => { 
                if (!paused) { 
                    timess++; 
                    if (timess >= 60) {
                        timess = 0;
                        timemm++;
                        if (timemm >= 60) {
                            timemm = 0;
                            timehh++;
                        }
                    }
                    hrs = String(timehh).padStart(2, '0');
                    min = String(timemm).padStart(2, '0');
                    sec = String(timess % 60).padStart(2, '0');
                    el.timerEl.textContent =  `‚è± ${String(hrs).padStart(2, '0')}:${String(min).padStart(2, '0')}:${String(sec).padStart(2, '0')}`;
                } 
            }, 1000); 
        }

        function stopTimer() { 
            if (timerInterval) { 
                clearInterval(timerInterval); 
                timerInterval = null; 
            }
        }

        // pause / resume timer
        el.pauseBtn.addEventListener('click', () => { 
            if(solvedMode) return;
            paused = !paused;
            el.pauseBtn.textContent = paused ? '‚ñ∂ Resume' : '‚è∏Pause';
            if (!paused && !timerInterval) { 
                if(!timerInterval) return;
                startTimer();
            } else {
                return;
            }

            if(paused) {
                paused = false;
                setStatus('Paused'); 
                textToSpeechEng('Pause');
            } else {
                paused = true;
                textToSpeechEng('Resume');
                setStatus('Resumed');
            }
        });

        // Sound / music
        // Sound objects
        const sounds = {
            tap: new Audio('assets/sound/tap-sound.mp3'),
            key: new Audio('assets/sound/single-key-press.mp3'),
            win: new Audio('assets/sound/winner-trumpets.mp3'),
            bg: new Audio('assets/sound/bg-music.mp3')
        };

        let soundEnabled = false;

        document.getElementById("toggle-sound").addEventListener("click", () => {
            soundEnabled = !soundEnabled;
            document.getElementById("toggle-sound").textContent = soundEnabled ? "üîä Sound: On" : "üîá Sound: Off";
            if (soundEnabled) sounds.bg.play();
            else sounds.bg.pause();
        });

        // Play sound helper
        // export function playSound(type) {
        function playSound(type) {
            if (sounds[type]) {
                sounds[type].currentTime = 0;
                sounds[type].play();
            }
        }

        // background music during page load and play
        window.addEventListener("load", () => {
            if (soundEnabled) playSound('bg');
        });

        // speeach in english
        // export function textToSpeechEng(text) {
        function textToSpeechEng(text) {
            let speechSynthesis = window.speechSynthesis;
            let utterance = new SpeechSynthesisUtterance();
            utterance.lang = "en-US";
            utterance.voice = speechSynthesis.getVoices().find(voice => voice.lang === 'en-US');
            utterance.text = text;
            speechSynthesis.speak(utterance);
        }

        /* initial build */
        (function init() {
            // fill size select values (already populated above)
            const initial = sizes.find(s => s.n === 9);
            buildBoard(initial.n, initial.box);
            setStatus('Ready ‚Äî Click number to start fill board');
            // window.addEventListener('resize', adjustSizes);
            window.addEventListener('resize', () => { 
                // const n = parseInt(el.sizeSelect.value); 
                // const opt = sizes.find(s => s.n === n);
                adjustSizes(); 
                // buildBoard(n, opt.box);
                // refreshAll();
            });
            setInterval(() => { if (!solvingInBackground) adjustSizes(); }, 400);
        })();
    </script>
</body>

</html>